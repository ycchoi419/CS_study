# 10 데이터베이스 저장과 접근 : 해싱

### 해싱(hashing) 방법

- 다른 레코드의 참조 없이 목표 레코드의 접근을 직접 지원
  - 직접 파일(direct file)
- 키(key) 값과 레코드 주소(address) 사이의 사상(mapping) 관계를 함수로 설정

- 해싱 함수(hashing function)
  - 키(key) 값으로부터 레코드 주소 (address)를 계산
  - 사상 함수 : 키 -> 주소
  - 삽입, 검색에 모두 이용



### 버킷 해싱

- 버킷(bucket) 
  - 하나의 주소를 가지면서 하나 이상의 레코드를 저장할 수 있는 파일의 한 구역
  - 버킷 크기 : 저장 장치의 물리적 특성과 한 번 접근으로 채취 가능한 레코드 수를 고려
- 버킷 해싱 : 키 -> 버킷 주소
- 충돌(collision) : 상이한 레코드들을 같은 주소(버킷)로 변환
  - 동거자(synonym)
  - 버킷 만원 - 오버플로 버킷
  - 한 번의 I/O가 추가됨



### 확장성 해싱(extendible hashing)

> 충돌에 대처하기 위해 제안된 기법
>
> 레코드 검색은 최대 2번의 디스크 접근만 필요
>
> 몇 개의 데이터가 들어올지 모르기 때문에 충분히 큰 데이터가 들어오더라도 확장 가능하도록 만듦

- 모조 키 (pseudokey)
  - 확장성 해싱 함수 : 키 값을 일정 길이의 비트 스트링, psedokey로 변환
  - psedokey의 처음 d 비트를 디렉터리의 인덱스로 사용
- 디렉터리(directory)
  - 헤더에 현재의 디렉터리 깊이 d를 유지
    - d : 전역 깊이(global depth)
  - 2^d 개의 버킷들을 지시할 수 있는 포인터 엔트리로 구성
  - 디스크에 저장

- 버킷
  - 헤더에 현재의 버킷 깊이 p를 유지
    - p : 지역 깊이(local depth)
  - 각 버킷에 저장된 레코드들의 모조 키들은 처음 p 비트가 모두 동일
  - 각 버킷마다 깊이가 다를 수 있음(모조 키 길이가 다름)
  - 데이터가 많아지면 depth를 하나씩 증가시키면서 기존의 버킷을 나누어주면 됨

