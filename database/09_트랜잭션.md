# 09 트랜잭션

- 트랜잭션(transaction)
  - 항공기 예약, 은행, 신용카드 처리, 대형 할인점 등에서는 대규모 데이터베이스를 수백, 수천 명 이상의 사용자들이 동시에 접근함
  - 많은 사용자들이 동시에 데이터베이스의 데이터베이스의 서로 다른 부분 또는 동일한 부분을 접근하면서 데이터베이스를 사용함
  - 동시성 제어(concurrency control)
    - 동시에 수행되는 트랜잭션들이 데이터베이스에 미치는 영향은 이들을 순차적으로 수행하였을 때 데이터베이스에 미치는 영향과 같다고 보장
    - 다수 사용자가 데이터베이스를 동시에 접근하도록 허용하면서 데이터베이스의 일관성을 유지함
  - 회복(recovery)
    - 데이터베이스를 갱신하는 도중에 시스템이 고장나도 데이터베이스의 일관성을 유지함



## 트랜잭션 개요

- 트랜잭션의 특성(ACID 특성)
  - 원자성(Atomicity)
    - 한 트랜잭션 내의 모든 연산들이 완전히 수행되거나 전혀 수행되지 않음(all or nothing)을 읨
    - DBMS의 회복 모듈은 시스템이 다운되는 경우에, 부분적으로 데이터베이스를 갱신한 트랜잭션의 영향을 취소함으로써 트랜잭션의 원자성을 보장함
    - 완료된 트랜잭션이 갱신한 사항은 트랜잭션의 영향을 재수행함으로써 트랜잭션의 원자성을 보장함
  - 일관성(Consistency)
    - 어떤 트랜잭션이 수행되기 전에 데이터베이스가 일관된 상태를 가졌다면 트랜잭션이 수행된 후에 데이터베이스는 또 다른 일관된 상태를 가짐
    - 트랜잭션이 수행되는 도중에는 데이터베이스가 일시적으로 일관된 상태를 갖지 않을 수 있음
  - 고립성(Isolation)
    - 한 트랜잭션이 데이터를 갱신하는 동안 이 트랜잭션이 완료되기 전에는 갱신 중인 데이터를 다른 트랜잭션들이 접근하지 못하도록 해야 함
    - 다수의 트랜잭션들이 동시에 수행되더라도 그 결과는 어떤 순서에 따라 트랜잭션들을 하나씩 차례대로 수행한 결과와 같아야 함
    - DBMS의 동시성 제어 모듈이 트랜잭션의 고립성을 보장함
    - DBMS는 응용들의 요구사항에 따라 다양한 고립 수준(isolation level)을 제공함
  - 지속성(Durability)
    - 일단 한 트랜잭션이 완료되면 이 트랜잭션이 갱신한 것은 그 후에 시스템에 고장이 발생하더라도 손실되지 않음
    - 완료된 트랜잭션의 효과는 시스템이 고장난 경우에도 데이터베이스에 반영됨
    - DBMS의 회복 모듈은 시스템이 다운되는 경우에도 트랜잭션의 지속성을 보장함
- 트랜잭션의 완료(commit)
  - 트랜잭션에서 변경하려는 내용에 데이터베이스에 완전하게 반영됨
  - SQL 구문상으로 COMMIT WORK
  - 트랜잭션이 성공적으로 끝났음
  - 데이터베이스는 새로운 일관된 상태를 가짐
  - 트랜잭션이 수행한 갱신을 데이터베이스에 반영해야 함
- 트랜잭션의 철회(abort)
  - 트랜잭션에서 변경하려는 내용이 데이터베이스에 일부만 반영된 경우에는 원자성을 보장하기 위해서, 트랜잭션이 갱신한 사항을 트랜잭션이 수행되기 전의 상태로 되돌림(Rollback)
  - SQL 구문상으로 ROLLBACK WORK
  - 트랜잭션의 일부를 성공적으로 끝내지 못했음
  - 데이터베이스가 불일치 상태를 가질 수 있음
  - 트랜잭션이 수행한 갱신이 데이터베이스에 일부 반영되었다면 취소해야 함
- 트랜잭션이 성공하지 못하는 원인
  - 시스템(사이트) 고장
    - 중앙처리장치, 주기억장치, 전원공급장치 등이 고장남
  - 트랜잭션 고장
    - 트랜잭션 고장은 트랜잭션이 수행되는 도중에 철회됨
    - DBMS 프로그램, 소프트웨어 등의 오류
  - 매체 고장
    - 디스크 헤드, 디스크 콘트롤러 등이 고장나서 보조기억장치의 전부 또는 일부 내용이 지워짐
  - 통신 고장
  - 자연적 재해
  - 부주의 또는 고의적인 고장



## 동시성 제어

- 동시성 제어
  - 대부분의 DBMS들은 다수 사용자용
  - 여러 사용자들이 동시에 동일한 테이블을 접근하기도 함
  - DBMS의 성능을 높이기 위해 여러 사용자의 질의나 프로그램들을 동시에 수행하는 것이 필수적
  - 동시성 제어 기법은 여러 사용자들이 다수의 트랜잭션을 동시에 수행하는 환경에서 부정확한 결과를 생성할 수 있는, 트랜잭션들 간의 간섭이 생기지 않도록 함
- 직렬 스케줄(serial schedule)
  - 여러 트랜잭션들의 집합을 한 번에 한 트랜잭션씩 차례대로 수행함
- 비직렬 스케줄(non-serial schedule)
  - 여러 트랜잭션들을 동시에 수행함
- 직렬가능(serializable)
  - 비직렬 스케줄의 결과가 어떤 직렬 스케줄의 수행 결과와 동등함
- 데이터베이스 연산
  - Input(X)
    - 데이터베이스 항목 X를 포함하고 있는 블록을 주기억장치의 버퍼로 읽어들임
  - Output(X)
    - 데이터베이스 항목 X를 포함하고 있는 블록을 디스크에 기록함
  - read_item(X)
    - 주기억장치 버퍼에서 데이터베이스 항목 X의 값을 프로그램 변수 X로 복사함
  - write_item(X) 
    - 프로그램 변수 X의 값을 주기억장치 내의 데이터베이스 항목 X에 기록함
- 동시성 제어를 하지 않고 다수의 트랜잭션을 동시에 수행할 때 생길 수 있는 문제
  - 갱신 손실(lost update)
    - 수행 중인 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어 씀으로써 갱신이 무효가 되는 것
  - 오손 데이터 읽기(dirty read)
    - 완료되지 않은 트랜잭션이 갱신한 데이터를 읽는 것
  - 반복할 수 없는 읽기(unrepeatable read)
    - 한 트랜잭션이 동일한 데이터를 두 번 읽을 때 서로 다른 값을 읽는 것

- Locking
  - Conflict가 발생하는 원인은 공유자원에 다수가 접근하기 때문
  - 데이터 항목을 로킹하는 개념은 동시에 수행되는 트랜잭션들의 동시성을 제어하기 위해서 가장 널리 사용되는 기법
  - **락(lock)**은 데이터베이스 내의 각 데이터 항목과 연관된 하나의 변수
  - 각 트랜잭션이 수행을 시작하여 데이터 항목을 접근할 때마다 요청한 락에 관한 정보는 **락 테이블(lock table)** 등에 유지됨
  - 트랜잭션에서 갱신을 목적으로 데이터 항목을 접근할 때는 **독점 락(X-lock, eXclusive lock)**을 요청함
    - X-lock의 경우 어떠한 경우도 다른 트랜잭션의 접근을 허용하지 않음
  - 트랜잭션에서 읽을 목적으로 데이터 항목을 접근할 때는 **공유 락(S-lock, Shared lock)**을 요청함
    - S-lock의 경우 다른 트랜잭션의 S-lock은 허용하지만 X-lock은 허락하지 않음
  - 트랜잭션이 데이터 항목에 대한 접근을 끝낸 후에 락을 해제(unlock)함
  - 데드락의 발생 가능성이 있음
- **2단계 라킹 프로토콜(2-phase locking protocol) : 2PL**
  - 락을 요청하는 것과 락을 해제하는 것이 2단계로 이루어짐
  - 락 확장 단계가 지난 후에 락 수축 단계에 들어감
  - 일단 락을 한 개라도 해제하면 락 수축 단계에 들어감
  - 락 확장 단계(1단계)
    - 락 확장 단계에서는 트랜잭션이 데이터 항목에 대하여 새로운 락을 요청할 수 있지만 보유하고 있던 락을 하나라도 해제할 수 없음
  - 락 수축 단계(2단계)
    - 락 수축 단계에서는 보유하고 있던 락을 해제할 수 있지만 새로운 락을 요청할 수 없음
    - 락 수축 단계에서는 락을 조금씩 해제할 수도 있고, 트랜잭션이 완료 시점에 이르렀을 때 한꺼번에 모든 락을 해제할 수도 있음
    - 일반적으로 한꺼번에 해제하는 방식이 사용됨
  - 락 포인트(lock point)는 한 트랜잭션에서 필요로 하는 모든 락을 걸어놓은 시점

- 데드록(deadlock)
  - 2단계 로킹 프로토콜에서도 데드록이 발생할 수 있음
  - 데드록은 두 개 이상의 트랜잭션들이 서로 상대방이 보유하고 있는 락을 요청하면서 기다리고 있는 상태를 말함
  - 데드락을 해결하기 위해서는 데드락을 방지하는 기법이나, 데드락을 탐지하고 희생자를 선정하여 데드락을 푸는 기법 등을 사용함
- 다중 락 단위(multiple granularity)
  - 대부분의 트랜잭션들이 소수의 투플들을 접근하는 데이터베이스 응용에서는 투플 단위로 락을 해도 락 테이블을 다루는 시간이 오래 걸리지 않음
  - 트랜잭션들이 많은 투플을 접근하는 데이터베이스 응용에서 투플 단위로만 락을 한다면 락 테이블에서 락 충돌을 검사하고 락 정보를 기록하는 시간이 오래 걸림
  - 트랜잭션이 접근하는 투플의 수에 따라 락을 하는 데이터 항목의 단위를 구분하는 것이 필요함
  - 데이터베이스에서 락을 할 수 있는 단위로는 데이터베이스, 릴레이션, 디스크불록, 투플 등
    - 데이터베이스 > 릴레이션 > 디스크 블록(페이지) > 레코드(투플) > (애트리뷰트 단위는 락 갯수가 너무 많아져서 사용하지 않음)
  - 일반적으로 DBMS는 각 트랜잭션에서 접근하는 투플 수에 따라 자동적으로 락 단위를 조정함
  - 락 단위가 작을수록 락킹에 따른 오버헤드가 증가함
  - 락 단위가 작을수록 동시성의 정도는 증가함



## 회복

- 회복의 필요성 
  - 어떤 트랜잭션 T를 수행하는 도중에 시스템이 다운되었을 때, T의 수행 효과가 디스크의 데이터베이스에 일부 반영되었을 수 있음
    - 어떻게 T의 수행을 취소하여 원자성을 보장할 것인가?
  - 또한 트랜잭션 T가 완료된 직후에 시스템이 다운되면 T의 모든 갱신 효과가 주기억장치로부터 디스크에 기록되지 않았을 수 있음
    - 어떻게 T의 수행 결과가 데이터베이스에 완전하게 반영되도록 하여 지속성을 보장할 것인가?
  - 디스크의 헤드 등이 고장나서 디스크의 데이터베이스를 접근할 수 없다면 어떻게 할 것인가?

- 회복의 개요
  - 여러 응용이 주기억장치 버퍼 내의 동일한 데이터베이스 항목을 갱신한 후에 디스크에 기록함으로써 성능을 향상시키는 것이 중요함
  - 버퍼의 내용을 디스크에 기록하는 것을 가능하면 최대한 줄이는 것이 일반적
  - 트랜잭션이 버퍼에는 갱신 사항을 반영했지만 버퍼의 내용이 디스크에 기록되기 전에 고장이 발생할 수 있음
  - 고장이 발생하기 전에 트랜잭션이 완료 명령을 수행했다면 회복 모듈은 이 트랜잭션의 갱신 사항을 재수행(REDO)하여 트랜잭션의 갱신이 지속성을 갖도록 해야함
  - 고장이 발생하기 전에 트랜잭션이 완료 명령을 수행하지 못했다면 원자성을 보장하기 위해서 이 트랜잭션이 데이터베이스에 반영했을 가능성이 있는 갱신 사항을 취소(UNDO)해야 함
- 저장 장치의 유형
  - 주기억장치와 같은 휘발성 저장 장치에 들어 있는 내용은 시스템이 다운된 후에 모두 사라짐
  - 디스크와 같은 비휘발성 저장 장치에 들어 있는 내용은 디스크 헤드 등이 손상을 입지 않는 한 시스템이 다운되 후에도 유지됨
  - 안전 저장 장치(stable storage)는 모든 유형의 고장을 견딜 수 있는 저장 장치를 의미
  - 두 개 이상의 비휘발성 저장 장치가 동시에 고장날 가능성이 매우 낮으므로 비휘발성 저장 장치에 두 개 이상의 사본을 중복해서 저장함으로써 안전 저장 장치를 구현함
- 재해적 고장과 비재해적 고장
  - 재해적 고장
    - 디스크가 손상을 입어서 데이터베이스를 읽을 수 없는 고장
    - 재해적 고장으로부터의 회복은 데이터베이스를 백업해놓은 자기 테이프를 기반으로 함
  - 비재해적 고장
    - 그 이외의 고장
    - 대부분의 회복 알고리즘들은 비재해적 고장에 적용됨
    - 로그를 기반으로 한 즉시 갱신, 로그를 기반으로 한 지연 갱신, 그림자 페이징(shadow paging) 등 여러 알고리즘
    - 대부분의 상용 DBMS에서 로그를 기반으로 한 즉시 갱신 방식을 사용

- 로그를 사용한 즉시 갱신
  - 즉시 갱신에서는 트랜잭션이 데이터베이스를 갱신한 사항이 주기억장치의 버퍼에 유지되다가 트랜잭션이 완료되기 전이라도 디스크의 데이터베이스에 기록될 수 있음
  - 데이터베이스에는 완료된 트랜잭션의 수행 결과 뿐만 아니라 철회된 트랜잭션의 수행 결과도 반영될 수 있음
  - 트랜잭션의 원자성과 지속성을 보장하기 위해  DBMS는 로그라고 부르는 특별한 화일을 유지함
  - 데이터베이스의 항목에 영향을 미치는 모든 트랜잭션의 연산들에 대해서 로그 레코드를 기록함
  - 각 로그 레코드는 로그 순서 번호(LSN: Log Sequence Number)로 식별됨