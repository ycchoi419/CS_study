# 04 관계 대수와 SQL

- 관계 데이터 모델에서 지원되는 두 가지 정형적인 언어
  - 관계 해석(relational calculus)
    - 원하는 데이터만 명시하고 질의를 어떻게 수행할 것인가는 명시하지 않는 선언적인 언어(what)
  - 관계 대수(relational algebra)
    - 어떻게 질의를 수행할 것인가를 명시하는 절차적 언어(what + how)
    - 관계 대수는 상용 관계 DBMS들에서 널리 사용되는 SQL의 이론적인 기초
    - 관계 대수는 SQL을 구현하고 최적화하기 위해 DBMS의 내부 언어로서도 사용됨
- SQL
  - 상용 관계 DBMS들의 사실상의 표준 질의어인 SQL을 이해하고 사용할 수 있는 능력은 매우 중요함
  - 사용자는 SQL을 사용하여 관계 데이터베이스에 릴레이션을 정의하고, 관계 데이터베이스에서 정보를 검색하고, 관계 데이터베이스를 갱신하며, 여러 가지 무결성 제약조건들을 명시할 수 있음



## 관계 대수

- 관계 대수 (relational algebra)
  - 연산자(관계 연산자), 피연산자(관계)가 존재 
  - relation을 input으로 받아서 새로운 relation을 output으로 내보냄
  - 기존의 릴레이션들로부터 새로운 릴레이션을 생성함
  - 릴레이션이나 관계 대수식(이것의 결과도 릴레이션임)에 연산자들을 적용하여 보다 복잡한 관계 대수식을 점차적으로 만들 수 있음
  - 기본적인 연산자들의 집합으로 이루어짐
  - 산술 연산자와 유사하게 단일 릴레이션이나 두 개의 릴레이션을 입력으로 받아 하나의 결과 릴레이션을 생성함
  - 결과 릴레이션은 또 다른 관계 연산자의 입력으로 사용될 수 있음
- 관계 연산자들의 종류
  - 필수적인 연산자
    - selection
    - projection
    - union
    - difference
    - Cartesian product
  - 편의를 위해 유도된 연산자
    - intersection
    - theta join
    - equijoin
    - natural join
    - semijoin
    - division
- 실렉션 연산자
  - 한 릴레이션(=table)에서 실렉션 조건(selection condition)을 만족하는 투플들의 부분 집합을 생성
  - predicate : 조건인 참인지 거짓인지를 판단하는 논리식. 실렉션 조건을 predicate라고도 함
  - 단항 연산자
  - 결과 릴레이션의 차수는 입력 릴레이션의 차수와 같음
  - 결과 릴레이션의 카디날리티는 항상 원래 릴레이션의 카디날리티보다 작거나 같음
  - 카디날리티 : 릴레이션 튜플의 개수
  - 실렉션 조건은 일반적으로 릴레이션의 임의의 애트리뷰트와 상수, 비교연산자(<, >, == 등), 부울 연산자(AND, OR, NOT 등)를 포함할 수 있음

- 프로젝션 연산자
  - 한 릴레이션의 애트리뷰트들의 부분 집합을 구함
  - 특정 column을 선택해서 구함
  - 중복 제거의 경우 시간이 매우 오래걸림
  - 실렉션의 결과 릴레이션에는 중복 튜플이 존재할 수 없지만, 프로젝션 결과 릴레이션의 경우 중복 튜플이 존재할 수 있음
- 집합 연산자
  - 릴레이션이 튜플들의 집합이기 때문에 기존의 집합 연산이 릴레이션에 적용됨
  - 세 가지 집합 연산자 : 합집합, 교집합, 차집합
  - 두 릴레이션이 집합 연산을 수행할 수 있는 조건(합집합 호환 : union compatible)을 만족해야 함
  - 합집합 호환 : 두 릴레이션 R1(A1, A2, ..., An)과 R2(B1, B2, ..., Bm)이 합집합 호환일 필요 충분 조건은 n=m이고 모든 1<=i<=n에 대해 domain(Ai)=domain(Bi)
  - 이항 연산자
- 카티션 곱 연산자
  - 카디날리티가 i인 릴레이션R(A1, A2, ... An)과 카디날리티가 j인 릴레이션 S(B1, B2, ..., Bm)의 카티션 곱 R × S는 차수(degree)가 n+m이고, 카디날리티가 i*j이고 애트리뷰터가 (A1, A2, ..., An, B1, B2, ..., Bm)이며 R과 S의 투플들의 모든 가능한 조합으로 이루어진 릴레이션
  - 카티션 곱의 결과 릴레이션의 크기가 매우 클 수 있으며, 사용자가 실제로 원하는 것은 카티션 곱의 결과 릴레이션의 일부인 경우가 대부분이므로 카티션 곱 자체는 유용한 연산자가 아님
  - 실제 응용에서는 사용되지 않고 join을 위한 연산일 뿐

- 관계 대수의 완전성
  - 실렉션, 프로젝션, 합집합, 차집합, 카티션 곱은 관계 대수의 필수적인 연산자
  - 다른 관계 연산자들은 필수적인 관계 연산자를 두 개 이상 조합하여 표현할 수 있음
  - 임의의 질의어(e.g. SQL)가 적어도 필수적인 관계 대수 연산자들만큼의 표현력을 갖고 있으면 **관계적으로 완전(relationally complete)**하다고 말함
- 조인 연산자
  - 두 개의 릴레이션으로부터 연관된 튜플을 결합하는 연산자
  - 관계 데이터베이스에서 두 개 이상의 릴레이션들의 관계를 다루는데 매우 중요한 연산자
  - theta join, equijoin, natural join, outer join, semijoin 등

- 세타 조인과 동등 조인
  - 세타 연산자 {=, !=, <>(XOR), <=, <, >=, >} 를 이용한 조인
  - 동등 조인의 경우 연산자가 =인 경우
- 자연 조인
  - 동등 조인의 결과 같은 값의 attribute가 중복해서 발생하므로 하나로 합친 join
  - 가장 많이 사용됨
- 디비전 연산자
  - 차수가 n+m인 릴레이션 R(A1, A2, ..., An, B1, B2, ..., Bm)과 차수가 m인 릴레이션 S(B1, B2, ..., Bm)의 디비전 R÷S는 차수가 n이고, S에 속하는 모든 투플 u에 대하여 투플 tu(투플 t와 u를 결합한 것)가 R에 존재하는 투플 t의 집합
  - 예시 : 전공 과목 5과목이 있고 학생들의 수강 정보를 모두 포함하는 테이블이 있을 때 모든 전공과목을 수강 중인 학생을 선택하기 위해서 전공과목 5개의 릴레이션으로 나누어주면 됨

- 관계 대수의 한계
  - 관계 대수는 산술 연산(덧셈, 뺄셈 등)을 할 수 없음
  - 집단 함수(aggregate function)를 지원하지 않음 : 개별적인 항목은 연산할 수 있지만 통계적인 값을 구할 수는 없음
  - 정렬을 나타낼 수 없음
  - 데이터베이스를 수정할 수 없음
  - 프로젝션 연산의 결과에 중복된 투플을 나타내는 것이 필요할 때가 있는데, 이를 명시하지 못함

- 추가된 관계 대수 연산자
  - 집단 함수 : 평균, 합계 등
  - 그룹화 : 부서 별 평균 등
  - 외부 조인
    - 상대 릴레이션에서 대응되는 투플을 갖지 못하는 투플이나 조인 attribute에 NULL 값이 들어있는 투플들을 다루기 위해서 조인 연산을 확장한 조인
    - 두 릴레이션에서 대응되는 투플들을 결합하면서, 대응되는 투플을 갖지 않는 투플과 join attribute에 NULL 값을 갖는 투플도 결과에 포함시킴
    - left outer join, right outer join, full outer join
  - left outer join
    - 릴레이션 R과 S의 조인을 할 때  R의 모든 투플들을 결과에 포함시키고, 만일 릴레이션 S에 관련된 투플이 없으면 결과 릴레이션에서 릴레이션 S의 attribute 들은 NULL 값으로 채움
  - 완전 외부 조인
    - left outer join + right outer join



## SQL 개요

- SQL 개요
  - SQL은 현재 DBMS 시장에서 관계 DBMS가 압도적 우위를 차지하는데 중요한 요인 중 하나
  - SQL은 IBM 연구소에서 1974년에 System R이라는 관계 DBMS 시제품을 연구할 때 관계 대수와 관계 해석을 기반으로 집단 함수, 그룹화, 갱신 연산 등을 추가하여 개발된 언어
  - 1986년에 ANSI(미국 표준 기구)에서 SQL 표준을 채택함으로써 SQL이 널리 사용되는데 기여
  - 다양한 상용 관계 DBMS마다 지원하는 SQL 기능에 다소 차이가 있음 
  - SQL은 비절차적 언어(선언적 언어)이므로 사용자는 자신이 원하는 바(what)만 명시하며, 원하는 것을 처리하는 방법(how)은 명시할 수 없음
  - 관계 DBMS는 사용자가 입력한 SQL문을 번역하여 사용자가 요구한 데이터를 찾는데 필요한 모든 과정을 담당
  - 자연어에 가까운 구문을 사용하여 질의를 표현할 수 있음
  - 두 가지 인터페이스
    - 대화식 SQL(interactive SQL)
    - 내포된 SQL(embedded SQL)
- SQL의 구성 요소
  - 데이터 정의어(DDL)
  - 데이터 조작어(DML)
  - 데이터 제어어(DCL)



## 데이터 정의어와 무결성 제약조건

- 데이터 무결성(Integrity)

  - 데이터의 정확성, 일관성을 나타냄
  - 데이터를 정확하고 일관되게 유지하는 것

- 무결성 제약조건(Integrity Constraint)

  - 데이터베이스의 정확성, 일관성을 보장하기 위해 저장, 삭제, 수정 등을 제약하기 위한 조건 
  - 데이터 무결성을 위한 조건

  1. 개체 무결성 : 각 릴레이션의 기본키를 구성하는 속성은 NULL 값이나 중복된 값을 가질 수 없다.
  2. 참조 무결성 : 외래키 값은 NULL 이거나 참조하는 릴레이션의 기본키 값과 동일해야 한다. 즉, 각 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다.
  3. 도메인 무결성 : 속성들의 값은 정의된 도메인에 속한 값이어야 한다.
  4. 고유 무결성 : 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우, 릴레이션의 각 튜플이 가지는 속성 값들은 서로 달라야 한다(UNIQUE 지정한 경우)
  5. NULL 무결성 : 릴레이션의 특정 속성 값은 NULL 이 될 수 없다. (NOT NULL 지정한 경우)
  6. 키 무결성 : 각 릴레이션은 최소한 한 개 이상의 키가 존재해야 한다. 

  

- 데이터 정의어(DDL)

  - CREATE : 생성
  - ALTER : 변경
  - DROP : 제거
  - 스키마의 생성과 제거
    - SQL2에서는 동일한 데이터베이스 응용에 속하는 릴레이션, 도메인, 제약조건, 뷰, 권한 등을 그룹화하기 위해서 스키마 개념을 지원

- 릴레이션 정의

```sql
CREATE TABLE DEPARTMENT 
	(DEPTNO INTEGER NOT NULL,
     DEPTNAME CHAR(10),
     FLOOR INTEGER,
     PRIMARY KEY(DEPTNO));
```

- 릴레이션의 정의에 사용되는 데이터 타입
  - INTEGER 또는 INT : 정수형
  - SMALL INT : 작은 정수형
  - NUMBER(n, s) 또는 DECIMAL(n, s) : n개의 숫자에서 소수 아래 숫자가 s개인 십진수
  - REAL : 실수형
  - FLOAT(n) : 적어도 n개의 숫자가 표현되는 실수형
  - CHAR(n) 또는 CHARACTER(n) : n바이트 문자열. n을 생략하면 1
  - VARCHAR(n) 또는 CHARACTER VARYING(n) : 최대 n바이트까지의 가변 길이 문자열
  - BIT(n) 또는 BIT VARYING(n) : n 개의 비트열 또는 최대 n개까지의 가변 비트열
  - DATE : 날짜형
  - BLOB : Binary LargeObject. 멀티미디어 데이터 등을 저장
- 릴레이션 제거

```sql 
DROP TABLE DEPARTMENT;
```

- ALTER TABLE

```sql
ALTER TABGLE EMPLOYEE ADD PHONE CHAR(13);
```

- 인덱스 생성
  - 검색을 빠르게 하기 위해 인덱스 추가

```sql
CREATE INDEX EMPDNO_IDX ON EMPLOYEE(DNO);
```

- 도메인 생성

```sql
CREATE DOMAIN DEPTNAME CHAR(10) DEFAULT '개발';
```

- 제약 조건

  - 릴레이션 정의에서 다양한 제약 조건을 명시
  - NOT NULL, CHECK를 이용해 조건을 명시할 수 있다

  ```SQL
  CREATE TABLE EMPLOYEE
  	(EMPNO INTEGER NOT NULL
       SALARY INTEGER CHECK (SALARY < 6000000),
       DNO INTEGER CHECK (DNO IN (1,2,3,4)) DEFAULT 1,
       PRIMARY KEY(EMPNO));
  ```

  - DELETE, UPDATE시에도 제약 조건 유지 가능
  - 무결성 제약조건의 추가 및 삭제

  ``` sql 
  ALTER TABLE STUDENT ADD CONSTRAINT STUDENT_PK PRIMARY KEY (STNO);
  -- 제약조건의 이름을 STUDENT_PK로 지정함 
  -- 제약 조건을 위배했을 경우 어떤 조건인지 알기 쉬움
  ```

  ```SQL
  ALTER TABLE STUDENT DROP CONSTRAINT STUDENT_PK;
  ```

  

## SELECT문

- SELECT문

  - 관계 데이터베이스에서 정보를 검색하는 SQL문
  - 관계 대수와 실렉션과 의미가 완전 다름
  - 관계 대수의 실렉션, 프로젝션, 조인, 카디션 곱 등을 결합한 것
  - 관계 데이터베이스에서 가장 자주 사용됨 
  - SELECT 결과 새로운 릴레이션이 생성됨

- 기본적인 SQL 질의

  - SELECT절과 FROM 절만 필수적이고 나머지는 선택 사항

    ```SQL
    SELECT 		(DISTINCT) 어트리뷰트(를)
    FROM 		릴레이션(들)
    (WEHRE		조건
    					(중첩 질의))
    (GROUP BY	애트리뷰트(들))
    (HAVING		조건)
    (ORDER BY 	어트리뷰트(들) (ASC|DESC));
    ```

  - 별칭(alias)

    - 서로 다른 릴레이션에 동일한 이름을 가진 애트리뷰터가 속해 있을 때 애트리뷰트의 이름을 구분하는 방법

    ```sql
    EMPLOYEE.DNO
    
    FROM EMPLOYEE AS E, DEPARTMENT AS D
    ```

  - 릴레이션의 모든 애트리뷰트나 일부 애트리뷰트 검색 : *

  - 문자열 비교 

    - % : 길이 상관 없음

    ```SQL
    WHERE EMPNAME LIKE '이%';
    -- '이'로 시작하는 모든 이름
    ```

  - 연산자들의 우선 순위

    1. 비교 연산자
    2. NOT
    3. AND
    4. OR

  - 범위를 사용한 검색

  ```SQL
  SELECT		EMPNAME, TITLE, SALARY
  FROM		EMPLOYEE
  WHERE		SALARY BETWEEN 3000000 AND 4500000;
  -- 아래와 같음
  SELECT		EMPNAME, TITLE, SALARY
  FROM		EMPLOYEE
  WHERE		SALARY >= 3000000 AND SALARY <= 4500000;
  ```

  - 리스트를 사용한 검색 : IN

  ```SQL
  SELECT 		*
  FROM 		EMPLOYEE
  WHERE 		DNO IN (1, 3);
  ```

  - SELECT절에서 산술연산자(+, -, *, /) 사용

  ```SQL
  SELECT 		EMPNAME, SALARY, SALARY * 1.1 AS NEWSALARY
  FROM		EMPLOYEE
  WHERE		TITLE = '과장';
  ```

  - NULL 값
    - NULL 값을 포함한 다른 값과 NULL 값을 +, - 등을 연산하면 결과는 NULL
    - COUNT(*)를 제외한 집단 함수들은 NULL 값을 무시함
    - 어떤 애트리뷰트에 들어 있는 값이 NULL인가 비교하기 위해서 'DNO=NULL'처럼 나타내면 안됨
    - 'DNO IS NULL'이 맞는 표현. NULL은 값이라고 보기 어려움.

- ORDER BY 절

  - 사용자가 SELECT문에서 질의 결과의 순서를 명시하지 않으면 릴레이션에 투플들이 삽입된 순서대로 사용자에게 제시됨
  - ORDER BY 절에서 하나 이상의 애트리뷰트를 사용하여 검색 결과를 정렬할 수 있음
  - SELECT 문에서 가장 마지막에 사용되는 절
  - 디폴트 정렬 순서는 오름차순(ASC)
  - DESC를 지정하여 정렬 순서를 내림차순으로 지정 가능
  - NULL 값은 오름차순에서는 가장 마지막에 나타나고, 내림차순에서는 가장 앞에 나타남
  - SELECT절에 명시한 애트리뷰트들을 사용해서 정렬해야 함

- 집단 함수
  - 데이터베이스에서 검색된 여러 투플들의 집단에 적용되는 함수
  - 한 릴레이션의 한 개의 애트리뷰트에 적용되어 단일 값을 반환함
  - SELECT절과 HAVING 절에만 나타날 수 있음
  - COUNT(*)를 제외하고는 NULL 값을 제거한 후 남아 있는 값들에 대해서 집단 함수의 값을 구함
  - COUNT(*)는 결과 릴레이션의 모든 행들의 총 갯수를 구하는 반면에 COUNT(애트리뷰트)는 해당 애트리뷰트에서 NULL 값이 아닌 값들의 갯수를 구함 
  - 키워드 DISTINCT가 집단 함수 앖에 사용되면 집단 함수가 적용되기 전에 먼저 중복을 제거함
  - 집단 함수의 기능
    - COUNT : 투플이나 값들의 개수
    - SUM : 값들의 합
    - AVG : 값들의 평균값
    - MAX : 값들의 최대값
    - MIN : 값들의 최소값

- 그룹화

  - GROUP BY 절에 사용된 애트리뷰트에 동일한 값을 갖는 투플들이 각각 하나의 그룹으로 묶임

  - 이 애트리뷰트를 그룹화 애트리뷰트(group attribute)라고 함

  - 각 그룹에 대하여 결과 릴레이션에 하나의 투플이 생성됨

  - SELECT절에는 각 그룹마다 하나의 값을 갖는 애트리뷰트, 집단 함수, 그룹화에 사용된 애트리뷰트들만 나타날 수 있음

  - 조건을 만족하는 그룹에 대해서만 결과를 얻고 싶을 때 HAVING 사용

  - HAVING절
    - 어떤 조건을 만족하는 그룹들에 대해서만 집단 함수를 적용할 수 있음
    - 각 그룹마다 하나의 값을 갖는 애트리뷰트를 사용하여 각 그룹이 만족해야 하는 조건을 명시함
    - 그룹화 애트리뷰트에 같은 값을 갖는 투플들의 그룹에 대한 조건을 나타내고, 이 조건을 만족하는 그룹들만 질의 결과에 나타남
    - HAVING 절에 나타나는 애트리뷰트는 반드시 GROUP BY 절에 나타나거나 집단 함수에 포함되어야 함

- 집합 연산

  - 집합 연산을 적용하려면 두 릴레이션이 합집합 호환성을 가져야 함
  - UNION(합집합), EXCEPT(차집합), INTERSECT(교집합), UNION ALL, EXCEPT ALL, INTERSECT ALL (ALL이 붙은 경우 중복되는 것을 제거하지 않고 포함함)

- JOIN

  - 조인은 두 개 이상의 릴레이션으로부터 연관된 투플들을 결합
  - 조인의 일반적인 형식은 아래의 SELECT문과 같이 FROM절에 두 개 이상의 릴레이션들이 열거되고, 두 릴레이션에 속하는 애트리뷰트들을 비교하는 조인 조건이 WHERE 절에 포함됨

  ```SQL
  SELECT		...
  FROM 		R, S
  WHERE		R.A <비교 연산자> S.B;
  ```

  - 조인 조건은 두 릴레이션 사이에 속하는 애트리뷰트 값들을 비교 연산자로 연결한 것
  - 조인 조건을 생략했을 때와 조인 조건을 틀리게 표현했을 때는 카티션 곱이 생성됨
  - 조인 질의가 수행되는 과정을 개념적으로 살펴보면 먼저 조인 조건을 만족하는 투플들을 찾고, 이 투플들로부터 SELECT 절에 명시된 애트리뷰트들만 프로젝트하고, 필요하다면 중복을 배제하는 순서로 진행됨
  - 조인 조건이 명확해지도록 애트리뷰트 이름 앞에 릴레이션 이름이나 투플 변수를 사용하는 것이 바람직
  - 두 릴레이션의 조인 애트리뷰트 이름이 동일하다면 반드시 애트리뷰트 이름 앞에 릴레이션 이름이나 투플 변수를 사용해야 함

- 자체 조인(SELF JOIN)
  - 한 릴레이션에 속하는 투플을 동일한 릴레이션에 속하는 투플들과 조인하는 것
  - 실제로는 한 릴레이션이 접근되지만 FROM절에 두 릴레이션이 참조되는 것처럼 나타내기 위해서 그 릴레이션에 대한 별칭을 두 개 지정해야 함

- 중첩 질의(nested query)

  - 외부 질의의 WHERE절에 다시 SELECT ... FROM ... WHERE 형태로 포함된 SELECT문
  - 부질의(subquery)라고 함
  - INSERT, DELETE, UPDATE문에도 사용될 수 있음
  - 중첩 질의의 결과로 한개의 스칼라값, 한 개의 애트리뷰트로 이루어진 릴레이션, 여러 애트리뷰트로 이루어진 릴레이션이 반환될 수 있음
  - 한 개의 애트리뷰트로 이루어진 릴레이션이 반환되는 경우
    - 중첩 질의의 결과로 한 개의 애트리뷰트로 이루어진 다수의 투플들이 반환될 수 있음
    - 외부 질의의 WHERE절에서 IN, ANY(SOME), ALL, EXISTS,와 같은 연산자를 사용해야 함
    - 키워드 IN은 한 애트리뷰트가 값들의 집합에 속하는가를 테스트할 때 사용됨
    - 한 애트리뷰트가 값들의 집합에 속하는 하나 이상의 값들과 어떤 관계를 갖는가를 테스트하는 경우에는 ANY를 사용
    - 한 애트리뷰트가 값들의 집합에 속하는 모든 값들과 어떤 관계를 갖는가를 테스트하는 경우에는 ALL을 사용

  - 여러 애트리뷰트들로 이루어진 릴레이션이 반환되는 경우

    - 중첩 질의의 결과로 여러 애트리뷰트들로 이루어진 릴레이션이 반환되는 경우엔 **EXISTS** 연산자를 사용하여 중첩 질의의 결과가 빈 릴레이션인지 여부를 검사함
    - 중첩 질의의 결과가 빈 릴레이션이 아니면 참이 되고, 그렇지 않으면 거짓

  - 상관 중첩 질의(correlated nested query)

    - 중첩 질의의 WHERE 절에 있는 프레디키트에서 외부 질의에 선언된 릴레이션의 일부 애트리뷰트를 참조하는 질의
    - 중첩 질의의 수행 결과가 단일 값이든, 하나 이상의 애트리뷰트로 이루어진 릴레이션이든 외부 질의로 한 번만 결과를 반환하면 상관 중첩 질의가 아님
    - 상관 중첩 질의에서는 외부 질의를 만족하는 각 투플이 구해진 후에 중첩 질의가 수행되므로 상관 중첩 질의는 외부 질의를 만족하는 투플 수만큼 여러 번 수행될 수 있음

    ```SQL
    SELECT 		EMPNAME, DNO, SALARY
    FROM 		EMPLOYEE E
    WHERE		SALARY >
    			(SELECT 	AVG(SALARY)
                FROM		EMPLOYEE
                WHERE		DNO = E.DNO);
    ```

    

## INSERT, DELETE, UPDATE 문

- INSERT문

  - 기존의 릴레이션에 투플을 삽입

  - 참조되는 릴레이션에 투플이 삽입되는 경우에는 참조 무결성 제약조건의 위배가 발생하지 않으나 참조하는 릴레이션 투플이 삽입되는 경우에는 참조 무결성 제약조건을 위배할 수 있음

  - 모든 ATTR이 없어도 필수 애트리뷰트만 있으면 삽입 가능

  - 릴레이션에 한 번에 한 투플씩 삽입하는 것과 한 번에 여러 개의 투플들을 삽입할 수 있는 것으로 구분

  - 릴레이션에 한 번에 한 투플씩 삽입하는 INSERT문

    ```SQL
    INSERT
    INTO 		릴레이션(ATTR1, ..., ATTRn)
    VALUES 		(값1, ..., 값n);
    ```

  

  - 릴레이션에 한 번에 여러 개의 투플들ㅇ르 삽입하는 INSERT문

  ```SQL
  INSERT
  INTO 		릴레이션(ATTR1, ..., ATTRn)
  SELECT		...		FROM 	...		WHERE 	...;
  ```

- DELETE문

  - 삭제 연산은 한 릴레이션으로부터 한 개 이상의 투플들을 삭제함
  - 참조되는 릴레이션의 삭제 연산의 결과로 참조 무결성 제약조건이 위배될 수 있으나, 참조하는 릴레이션에서 투플을 삭제하면 참조 무결성 제약조건을 위배하지 않음

  ```SQL
  DELETE
  FROM 		릴레이션
  WHERE		조건;
  ```

- UPDATE문

  - 한 릴레이션에 들어 있는 투플들의 애트리뷰트 값들을 수정
  - 기본 키나 외래 키에 속하는 애트리뷰트의 값이 수정되면 참조 무결성 제약 조건을 위배할 수 있음

  ```SQL
  UPDATE 		릴레이션
  SET			애트리뷰트 = 값 또는 식
  WHERE		조건;
  ```



## 트리거(trigger)와 주장(assertion)

- 트리거

  - 명시된 이벤트(데이터베이스의 갱신)가 발생할 때마다 DBMS가 자동적으로 수행하는, 사용자가 정의하는 문(프로시저)

  - 데이터베이스의 무결성을 유지하기 위한 일반적이고 강력한 도구

  - 테이블 정의시 표현할 수없는 기업의 비즈니스 규칙들을 시행하는 역할

  - 트리거를 명시하려면 트리거를 활성화시키는 사건인 이벤트, 트리거가 활성화되었을 때 수행되는 테스트인 조건, 트리거가 활성화되고 조건이 참일 때 수행되는 문(프로시져)인 동작을 표현해야 함

  - 트리거를 이벤트-조건-동작(ECA) 규칙이라고도 부름

    E는 Event, C는 Condition, A는 Action을 의미

  - 트리거를 너무 많이 만들면 큰 오버헤드가 발생. 조건이 만족할 때에만 수행되도록 해야함

  - SQL3에서 트리거의 형식

  ```SQL
  CREATE TRIGGER 		<트리거 이름>
  AFTER				<트리거를 유발하는 이벤트들이 OR로 연결된 리스트> ON <릴레이션>
  (WHEN				<조건>)
  BEGIN				<SQL문> END
  ```

  - 이벤트의 가능한 예로는 테이블에 투플 삽입, 테이블로부터 투플 삭제, 테이블의 투플 수정 등이 있음
  - 조건은 임의의 형태의 프레디키트
  - 동작은 데이터베이스에 대한 임의의 갱신
  - 어떤 이벤트가 발생했을 때 조건이 참이 되면 트리거와 연관된 동작이 수행되고, 그렇지 앟으면 아무 동작도 수행되지 않음
  - 삽입, 삭제, 수정 등이 일어나기 전(before)에 동작하는 트리거와 일어난 후(after)에 동작하는 트리거로 구분
  - 연쇄적으로 활성화되는 트리거
    - 하나의 트리거가 활성화되어 이 트리거 내의 한 SQL문이 수행되고, 그 결과로 다른 트리거를 활성화하여 그 트리거 내의 SQL문이 수행될 수 있음

- 주장(assertion)

  - assertion은 SQL3에 포함되어 있으나 대부분의 사용 RDBMS가 아직 지원하고 있지 않음
  - 트리거는 제약조건을 위반했을 때 수행할 동작을 명시하는 것이고, 주장은 제약조건을 위반하는 연산이 수행되지 않도록 함
  - 주장의 구문

  ```SQL
  CREATE ASSERTION 	이름
  CHECK				조건;
  ```

  - 트리거보다 좀 더 일반적인 무결성 제약조건
  - DBMS는 주장의 프레디키트를 검사하여 만일 참이면 주장을 위배하지 않는 경우이므로 데이터베이스 수정이 허용됨
  - 일반적으로 두 개 이상의 테이블에 영향을 미치는 제약조건을 명시하기 위해 사용됨



## embedded SQL

- 내포된 SQL(embedded SQL)
  - SQL이 호스트 언어의 완전한 표현력을 갖고 있지 않기 때문에 모든 질의를 SQL로 표현할 수는 없음
  - SQL은 호스트 언어가 갖고 있는 조건문(IF문), 반복문(WHILE문), 입출력 등과 같은 동작, 사용자와의 상호 작용, 질의 결과를 GUI로 보내는 등의 기능을 갖고 있지 않음
  - C, C++, 코볼, 자바 등의 언어로 작성하는 프로그램에 SQL문을 삽입하여, 데이터베이스를 접근하는 부분을 SQL이 맡고 SQL에 없는 기능은 호스트 언어로 작성하는 것이 필요
  - 호스트 언어에 포함되는 SQL문을 내포된 SQL이라 부름
  - 데이터 구조가 불일치하는 문제(**impedance mismatch**) 
    - 프로그래밍 언어는 릴레이션을 저장할 수 없음(레코드로 저장)
  - MS SQL SERVER 2005에서 C 언어에 SQL문을 내포시키는 환경을 ESQL/C라고 부름
  - 호스트 언어로 작성중인 프로그램에 SQL문을 내포시킬 때 해당 호스트 언어의 컴파일러가 어떻게 호스트 언어의 문과 SQL문을 구별할 것인가?
  - 호스트 언어로 작성 중인 프로그램에 포함된 SELECT, INSERT, DELETE, UPDATE등 모든 SQL문에는 반드시 문장의 앞부분에 **EXEC SQL**을 붙임
  - EXEC SQL은 EXEC SQL부터 세미콜론 사이에 들어 있는 문장이 내포된 SQL문임을 전컴파일러에게 알림
  - ESQL/C 전컴파일러(precompiler)는 내포된 SQL문을 C 컴파일러에서 허용되는 함수 호출로 변환함

- ESQL/C
  - ESQL/C는 정적인 SQL문과 동적인 SQL문 모두를 지원함
  - 정적인 SQL문은 C 프로그램에 내포된 완전한 Transact-SQL문
  - 동적인 SQL문은 불완전한 Transact-SQL문으로서 일부 또는 전부를 질의가 수행될 때 입력 가능
  - 정적인 SQL문은 입력값과 출력 데이터를 위해서 C 프로그램의 변수들을 포함할 수 있음
  - SQL문에 포함된 C 프로그램의 변수를 **호스트 변수**(host variable)라고 부름

- 불일치 문제와 커서
  - 호스트 언어는 단일 변수/레코드 위주의 처리(투플 위주의 방식)를 지원하는 반면에 SQL은 데이터 레코드들의 처리(집합 위주의 방식)를 지원하기 때문에 불일치 문제가 발생함
  - 이를 해결하기 위해서 LOOP(FOR문)을 사용함
  - 불일치 문제를 해결하기 위해서 커서(cursor)가 사용됨
  - 커서는 한 번에 한 투플씩 가져우는 수단
  - DECLARE CURSOR문을 사용하여 커서를 정의함
  - OPEN cursor문은 질의를 수행하고, 질의 수행 결과의 첫 번째 투플 이전을 커서가 가리키도록 한다. 이것이 커서의 현재 투플
  - 그 다음에 FETCH문은 커서를 다음 투플로 이동하고, 그 투플의 애트리뷰트 값들을 FETCH문에 명시된 호스트 변수들에 복사함
  - CLOSE cursor는 커서를 닫음
  - 만일 갱신할 투플들에대한 커서를 정의할 때는 커서 선언부에 FOR UPDATE OF 절을 반드시 포함시키고, 수정할 애트리뷰트들을 함께 명시함

- SQL 통신 영역(SQLCA : SQL Communications Area)
  - C 프로그램에 내포된 SQL문에 발생하는 에러들을 사용자에게 알려줌
  - 사용자는 SQLCA 데이터 구조의 에러 필드와 상태 표시자를 검사하여 내포된 SQL문에 성공적으로 수행되었는가 또는 비정상적으로 수행되었는가를 파악할 수 있음
  - SQLCA 데이터 구조 중에서 가장 중요하고 널리 사용되는 필드는 SQLCODE 변수
  - SQLCODE의 값이 0이면 마지막에 내포된 SQL문이 성공적으로 끝났음을 의미