# 07 릴레이션 정규화

## 정규화 개요

- 릴레이션 정규화
  - 부주의한 데이터베이스 설계는 제어할 수 없는 데이터 중복을 야기하야 여러 가지 **갱신 이상**(update anomaly)을 유발함
  - 어떻게 좋은 데이터베이스 설계를 할 것인가? 데이터베이스에 어떤 릴레이션들을 생성할 것인가? 각 릴레이션에 어떤 애트리뷰트들을 둘 것인가?
  - **정규화**(normalization)는 주어진 릴레이션 스키마를 함수적 종속성과 기본 키를 기반으로 분석하여, 원래의 릴레이션을 분해함으로써 중복과 세 가지 갱신 이상을 최소화함
- 좋은 관계 데이터베이스 스키마를 설계하는 목적
  - **정보의 중복**과 **갱신 이상**이 생기지 않도록 하고, 정보의 손실을 막으며, 실세계를 훌륭하게 나타내고, 애트리뷰트들 간의 관계가 잘 표현되는 것을 보장하며, 어떤 무결성 제약조건의 시행을 간단하게 하며, 아울러 효율성 측면도 고려하는 것
  - 먼저 갱신 이상이 발생하지 않도록 노력하고, 그 다음에 효율성을 고려함
- 갱신 이상(update anomaly)
  - 수정 이상(modification anomaly)
    - 반복된 데이터 중에 일부만 수정하면 데이터의 불일치가 발생
  - 삽입 이상(insertion anomaly)
    - 불필요한 정보를 함께 저장하지 않고는 어떤 정보를 저장하는 것이 불가능
  - 삭제 이상(deletion anomaly)
    - 유용한 정보를 함께 삭제하지 않고는 어떤 정보를 삭제하는 것이 불가능
- 릴레이션 분해
  - 하나의 릴레이션을 두 개 이상의 릴레이션으로 나누는 것
  - 릴레이션의 분해는필요한 경우에는 분해된 릴레이션들로부터 원래의 릴레이션을 다시 구할 수 있음을 보장해야 한다는 원칙을 기반
  - 분해를 잘못하면 두 릴레이션으로부터 얻을 수 있는 정보가 원래의 릴레이션이 나타내던 정보보다 많을 수도있고 적을 수도 있음
  - 릴레이션의 분해는 릴레이션에 존재하는 함수적 종속성에 관한 지식을 기반으로 함
- 정규형(normal form)의 종류
  - 제1정규형(first normal form)
  - 제2정규형(second normal form)
  - 제3정규형(third normal form)
  - BCNF(Boyce-Codd normal form)
  - 제4정규형(fourth normal form)
  - 제5정규형(fifth normal form)
  - 일반적으로 산업계의 데이터베이스 응용에서 데이터베이스를 설계할 때 BCNF까지만 고려함
- 관계 데이터베이스 설계의 비공식적인 지침
  1. 이해하기 쉽고 명확한 스키마를 만들라 : 여러 엔티티 타입이나 관계 타입에 속한 애트리뷰트들을 하나의 릴레이션에 포함시키지 않음
  2. NULL값을 피하라
  3. 가짜 투플이 생기지 않도록 하라
  4. 스키마를 정제하라



## 함수적 종속성

- 함수적 종속성의 개요

  - 정규화 이론의 핵심
  - 릴레이션의 애트리뷰트들의 의미로부터 결정됨
  - 릴레이션 스키마에 대한 주장이지, 릴레이션의 특정 인스턴스에 대한 주장이 아님
  - 릴레이션의 가능한 모든 인스턴스들이 만족해야 함
  - 실세계에 대한 지식과 응용의 의미를 기반으로 어떤 함수적 종속성들이 존재하는가를 파악해야 함
  - 함수적 종속성은 제2정규형부터 BNCF까지 적용됨

- 결정자(determinant)

  - 어떤 애트리뷰트의 값은 다른 애트리뷰트의 값을 고유하게 결정할 수 있음

  - 결정자는 주어진 릴레이션에서 다른 애트리뷰트(또는 애트리뷰트들의 집합)를 고유하게 결정하는 하나 이상의 애트리뷰트를 의미

  - 결정자를 아래와 같이 표기하고, 이를 "A가 B를 결정한다" (또는 "A는 B의 결정자이다")라고 말함

    A -> B

  - 키는 다른 애트리뷰트를 결정할 수 있음(키의 값과 다른 애트리뷰트의 값이 유일할 때)

- 함수적 종속성

  - 만일 애트리뷰트 A가 애트리뷰트 B의 결정자이면 B가 A에 함수적으로 종속한다고 말함
  - 다른 말로 표현하면, 주어진 릴레이션 R에서 애트리뷰트 B가 애트리뷰트 A에 함수적으로 종속하는 필요 충분 조건은 각 A 값에 대해 반드시 한 개의 B 값이 대응된다는 것

- 완전 함수적 종속성(FFD: Full Functional Dependancy)

  - 주어진 릴레이션 R에서 애트리뷰트 B가 애트리뷰트 A에 함수적으로 종속하면서 애트리뷰트 A의 어떠한 진부분집합에도 함수적으로 종속하지 않으면 애트리뷰트B가 애트리뷰트A에 완전하게 함수적으로 종속한다고 말함
  - 여기서 애트리뷰트 A는 복합 애트리뷰트

- 부분 함수적 종속성(PFD: Partial Functional Dependancy)

  - 어떤 애트리뷰트가 애트리뷰트 일부에만 종속관계를 가지고 있을 때 부분 함수적 종속이라고 함
  - 부분 함수적 종속성을 없애도록 Decompose해야 함

- 이행적 함수적 종속성(transitive FD)

  - 한 릴레이션의 애트리뷰트 A, B, C가 주어졌을 때 애트리뷰트 C가 이행적으로 A에 종속한다(A -> C)는 것의 필요 충분 조건은 A -> B && B-> C 가 성립하는 것
  - A가 릴레이션의 기본 키라면 키의 정의에 따라 A->B와 A->C가 성립, 만일 C가 A외에 B에도 함수적으로 종속한다면 C는 A에 직접 함수적으로 종속하면서 B를 거쳐서 A에 이행적으로 종속



## 릴레이션 분해

- 릴레이션 분해
  - 하나의 릴레이션을 두개 이상의 릴레이션으로 나누는 것
  - 릴레이션을 분해하면 중복이 감소되고 갱신 이상이 줄어드는 장점이 있는 반면에, 바람직하지 않은 문제들을 포함하여 몇 가지 잠재적인 문제들을 야기할 수 있음
    - 릴레이션이 분해되기 전에는 조인이 필요 없는 질의가 분해 후에는 조인을 필요로 하는 질의로 바뀔 수 있음
    - 분해된 릴레이션들을 사용하여 원래 릴레이션을 재구성하지 못할 수 있음
- 무손실 분해(lossless decomposition)
  - 분해된 두 릴레이션을 조인하면 원래의 릴레이션에 들어있는 정보를 완전하게 얻을 수 있음
  - 여기서 손실이란 정보의 손실을 뜻함
  - 정보의 손실은 원래의 릴레이션을 분해한 후에 생성된 릴레이션들을 조인한 결과에 들어있는 정보가 원래의 릴레이션에 들어있는 정보보다 적거나 많은 것을 모두 포함



## 제1정규형, 제2정규형, 제3정규형, BCNF

- 제1정규형
  - 한 릴레이션 R이 제1정규형을 만족할 필요 충분 조건은 릴레이션 R의 모든 애트리뷰트가 원자값만을 갖는다는 것
  - 모든 릴레이션이 제1정규형임
  - 즉, 릴레이션의 모든 애트리뷰트에 반복 그룹(repeating group)이 나타나지 않으면 제1정규형을 만족함
  - N1NF(non-first normal form)
    - 제1정규형이 아닌 것
    - 원자값이 아닌 반복 그룹으로 표현한 것
- 제1정규형에 존재하는 갱신 이상
  - 수정이상
    - 중복된 값이 나타날 수 있어 한 정보가 변경되는 경우 여러 투플들을 모두 수정해야 한다. 
  - 삽입이상
    - 하나의 값에 대한 애트리뷰트가 존재하지 않으면 엔티티 무결성 제약조건에 따라 투플을 삽입할수 없을 수 있다.
  - 삭제 이상
    - 하나의 투플에 모든 정보가 담겨있는 경우 한 투플을 삭제하면 필요한 정보가 같이 삭제될 수 있다. 

- 제2정규형
  - 한 릴레이션 R이 제2정규형을 만족할 필요 충분 조건은 릴레이션이 제1정규형을 만족하면서, 어떤 후보 키에도 속하지 않는 모든 애트리뷰트들이 R의 기본 키에 완전하게 함수적으로 종속하는 것
  - 기본 키가 두 개 이상의 애트리뷰트로 구성되었을 경우에만 제1정규형이 제2정규형을 만족하는가를 고려할 필요가 있음
  - 제2정규형에서 갱신 이상이 발생함 : 릴레이션에 이행적 종속성이 존재하기 때문
- 제3정규형
  - 한 릴레이션 R이 제3정규형을 만족할 필요 충분 조건은 릴레이션 R이 제2정규형을 만족하면서, 키가 아닌 모든 애트리뷰트가 릴레이션 R의 기본 키에 이행적으로 종속하지 않는 것
  - 제3정규형에서 갱신 이상이 발생함: 키가 아닌 애트리뷰트가 다른 애트리뷰트를 결정하기 때문

- BCNF(Boyce-Codd normal form)
  - 한 릴레이션 R이 BCNF를 만족할 필요 충분 조건은 릴레이션 R이 제3정규형을 만족하고 모든 결정자가 후보 키이어야 함
  - 위의 수강 릴레이션에서 강사 애트리뷰트는 후보 키가 아님에도 불구하고 과목 애트리뷰트를 결정하기 때문에 BCNF가 아님
  - 제3정규형을 만족하는 대부분의 릴레이션들은 BCNF도 만족함
  - 하나의 후보 키만을 가진 릴레이션이 제3정규형을 만족하면 동시에 BCNF도 만족함
  -  제3정규형을 만족하는 릴레이션을 BCNF으로 정규화하려면 키가 아니면서 결정자 역할을 하는 애트리뷰트와 그 결정자에 함수적으로 종속하는 애트리뷰트를 하나의 테이블에 넣음. 이 릴레이션에서 결정자는 기본 키가 됨
  - 그 다음에는 기존 릴레이션에 결정자를 남겨서 기본 키의 구성 요소가 되도록 함. 또한 이 결정자는 새로운 릴레이션에 대한 외래키 역할도 함



## 역정규화

- 역정규화
  - 정규화 단계가 진행될수록 중복이 감소하고 갱신 이상도 감소됨 
  - 정규화가 진전될수록 무결성 제약조건을 시행하기 위해 필요한 코드의 양도 감소됨
  - 정규화가 데이터베이스 설계의 중요한 요소이지만 성능상의 관점에서만 보면 높은 정규형을 만족하는 릴레이션 스키마가 최적인 것은 아님
  - 한 정규형에서 다음 정규형으로 진행될 때마다 하나의 릴레이션이 최소한 두 개의 릴레이션으로 분해됨 
  - 분해되기 전의 릴레이션을 대상으로 질의를 할 때는 조인이 필요 없지만 분해된 릴레이션을 대상으로 질의를 할 때는 같은 정보를 얻기 위해서 보다 많은 릴레이션들을 접근해야 하므로 조인의 필요성이 증가함
  - 때로 데이터베이스 설계자는 응용의 요구 사항에 따라 데이터베이스 설계의 일부분을 역정규화함으로써 데이터 중복 및 갱신 이상을 대가로 치르면서 성능상의 요구를 만족시키기도 함
  - 많은 데이터베이스 응용에서 검색 질의의 비율이 갱신 질의의 비율보다 훨씬 높음. 역정규화는 주어진 응용에서 빈번하게 수행되는 검색 질의들의 수행 속도를 높이기 위해서 이미 분해된 두 개 이상의 릴레이션들을 합쳐서 하나의 릴레이션으로 만드는 과정
  - 즉 역정규화는 보다 낮은 정규형으로 되돌아가는 것